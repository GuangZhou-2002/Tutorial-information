<!--
 * @Author: your name
 * @Date: 2020-06-19 14:37:15
 * @LastEditTime: 2020-06-19 14:51:36
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /day30/代码/笔记.md
--> 
(1) 混入式继承(拷贝) 
  - 适用于单个的普通对象的情况(浅拷贝和深拷贝)

(2) 原型式继承(通过设置原型对象共享) 
  - 适用于两个构造函数创建实例对象的结构
  - 核心：子构造函数.prototype = 父构造函数.prototype
  - 解决：
    - 在子构造函数的实例化对象中能够访问到父构造函数原型对象上面的成员  
       * 继承了父构造函数的原型成员
  - 特点：
      [√] 父类的原型成员
      [x] 父类的实例成员
  - 问题：父类的实例成员 && 存在共享的问题 

(3) 原型链继承(借助原型链) 
  - 核心：设置子构造函数的原型对象指向父构造函数的实例对象 
      * 子构造函数.prototype = new 父构造函数
  - 特点：
      [√] 父类的原型成员
      [√] 父类的实例成员
  - 问题：
      * 无法向父构造函数传递参数

(4) 借用构造函数实现继承 
  - 核心：在子构造函数的内容调用父构造函数并且绑定this为当前的实例对象
    * Person.call(this, name, address);
  - 解决
      [√] 父类的实例成员，并且可以传递参数
      [x] 父类的原型成员
  
(5) 组合继承
  - 核心：借用构造函数继承 + 原型式继承
    * Person.call(this, name, address)   <!--实例成员  -->
    * Boy.prototype = Person.prototype;  <!--原型成员  -->

(6) class实现继承


设计模式(23种)：套路，在长达的几十年的编程领域中由很多技术专家总结出来的套路。